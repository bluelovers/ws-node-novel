{"version":3,"file":"interface.js","sourceRoot":"","sources":["interface.ts"],"names":[],"mappings":";AAAA;;GAEG","sourcesContent":["/**\n * Created by user on 2018/11/11/011.\n */\n\nimport { PathLike } from 'fs';\nimport { Runtime } from 'inspector';\nimport { URL } from \"url\";\nimport { execall } from 'execall2';\nimport { isRegExp, zhRegExp } from 'regexp-cjk';\n\nexport type IPathLike = string\nexport type IContext = string | Buffer\n\nexport type IRegExpLike = typeof RegExp |\n\ttypeof zhRegExp |\n\t{\n\t\tnew(...argv): RegExp\n\t} |\n\t{\n\t\tnew(...argv): zhRegExp\n\t}\n\t;\n\nexport type Diff<T extends string, U extends string> =\n\t({[P in T]: P } & {[P in U]: never } & { [x: string]: never })[T];\n// @ts-ignore\nexport type Omit<T, K extends keyof T> = Pick<T, Diff<keyof T, K>>;\n// @ts-ignore\nexport type Overwrite<T, U> = Omit<T, Diff<keyof T, Diff<keyof T, keyof U>>> & U;\n\nexport interface IOptionsRequired<P = boolean | IRegExpLike> extends IOptions<P>\n{\n\tchapter: ISplitOption,\n}\n\nexport type IOptionsRequiredUser = Overwrite<IOptionsRequired, IOptionsRequiredLazyInput> | IOptionsRequired\n\nexport interface IOptionsRequiredLazyInput\n{\n\tvolume?: ISplitOptionVolume<string | RegExp | string[]>,\n\tchapter: ISplitOption<string | RegExp | string[]>,\n\n\tuseRegExpCJK?: boolean | IRegExpLike,\n}\n\nexport interface IOptions<P = boolean | IRegExpLike>\n{\n\tfile?: IPathLike,\n\toutDir?: string,\n\n\tvolume?: ISplitOptionVolume,\n\tchapter?: ISplitOption,\n\n\tdirname?: string,\n\t//ix?: number,\n\n\t/**\n\t * 檔名序列的長度 不足此長度時 會自動補 0\n\t */\n\tindexPadLength?: number;\n\n\t/**\n\t * 使用 zhRegExp 來自動處理異體字\n\t *\n\t * @default true\n\t */\n\tuseRegExpCJK?: P,\n\n\tbeforeStart?<O extends IOptions>(options: O): void,\n\n\t/**\n\t * 允許在讀取檔案後 先對檔案內容做處理變更\n\t */\n\treadFileAfter?(txt: string): string | void,\n\n\tsaveFileBefore?(txt: string, cn: string, data_vn: IDataChapter, cache: ISaveFileBeforeCache): string | null,\n\n\t[key: string]: any,\n}\n\nexport interface ISaveFileBeforeCache\n{\n\tfile: string,\n\tfull_file: string,\n\tdata: IDataVolume,\n\toptions: IOptions,\n\tcn: string,\n\tvn: string,\n}\n\nexport type ISplitOptionVolume<T extends RegExp | string | string[] = RegExp> = ISplitOption<T> & {\n\n\t/**\n\t * 禁用此規則\n\t */\n\tdisable?: boolean,\n\n\t/**\n\t * 允許找不到配對\n\t */\n\tallowNoMatch?: boolean,\n\n}\n\nexport interface ISplitOption<T extends RegExp | string | string[] = RegExp>\n{\n\t/**\n\t * 配對章節的 RegExp\n\t */\n\tr: T,\n\n\tflags?: string,\n\n\t/**\n\t * 處理本次配對切割的 callback\n\t */\n\tcb?: ISplitCB,\n\n\t/**\n\t * 檢查 配對後的內容 如果符合 則忽略\n\t * 適用於某些狀況下無法將特定內容排除 導致被錯誤切割\n\t * 例如 黑之魔王 的整合\n\t */\n\tignoreRe?: T,\n\tignoreFlags?: string,\n\tignoreCb?: ISplitIgnoreCB,\n}\n\nexport interface ISplitCache extends IOptions\n{\n\t/**\n\t * 於所有章節中的序列\n\t * 請勿修改此值\n\t */\n\tix: number,\n\t/**\n\t * txt 內容\n\t * 請勿修改此值\n\t */\n\ttxt: string,\n}\n\nexport type ISplitMatch = ReturnType<typeof execall>\nexport type ISplitMatchItem = ISplitMatch[0]\n\nexport interface ISplitCBParameters extends ISplitCBReturn\n{\n\t/**\n\t * 於 match 列表中的 index 序列\n\t */\n\ti: string,\n\t/**\n\t * 本階段的 match 值\n\t */\n\tm: ISplitMatchItem,\n\t/**\n\t * 上一次的 match 值\n\t *\n\t * 但是 實際上 這參數 才是本次 callback 真正的 match 內容\n\t */\n\tm_last: ISplitMatchItem,\n\t/**\n\t * 目前已經分割的檔案列表與內容\n\t */\n\t_files: IDataChapter,\n\t/**\n\t * 於所有章節中的序列\n\t *\n\t * @readonly\n\t */\n\tii: string,\n\tcache: Partial<ISplitCache>,\n}\n\nexport interface ISplitCBReturn\n{\n\t/**\n\t * 檔案序列(儲存檔案時會做為前置詞)\n\t */\n\tid: string,\n\t/**\n\t * 標題名稱 預設情況下等於 match 到的標題\n\t */\n\tname: string,\n\t/**\n\t * 本次 match 的 內文 start index\n\t * 可通過修改數值來控制內文範圍\n\t *\n\t * @example\n\t * idx += m_last.match.length; // 內文忽略本次 match 到的標題\n\t */\n\tidx: number,\n}\n\nexport interface ISplitCB extends Function\n{\n\t(argv: ISplitCBParameters): ISplitCBReturn;\n}\n\nexport interface ISplitIgnoreCB extends Function\n{\n\t(argv: ISplitCBParameters): boolean;\n}\n\nexport interface IOptionsWithData<T extends IContext = string> extends IOptions\n{\n\tdata: IDataVolume<T>,\n\toptions?: IOptionsWithData | IOptions,\n}\n\nexport interface IDataVolume<T extends IContext = string>\n{\n\t'00000_unknow'?: IDataChapter<T>,\n\n\t[dirname: string]: IDataChapter<T>,\n}\n\nexport interface IDataChapter<T extends IContext = string>\n{\n\t[chapter: string]: T\n}\n\nexport type Resolvable<R> = R | PromiseLike<R>;\n\n"]}